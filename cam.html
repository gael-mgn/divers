<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Prendre une photo ‚Äî Cam√©ra optimis√©e mobile</title>
  <style>
    :root{
      --bg:#f5f5f5; --primary:#007bff; --primary-hover:#0056b3; --danger:#dc3545;
      --modal-bg: rgba(0,0,0,0.75); --max-width:900px;
    }
    html,body{height:100%; margin:0; font-family: Arial, sans-serif; background:var(--bg); color:#222;}
    .wrap{display:flex;align-items:center;justify-content:center;height:100%;padding:20px;}
    button{padding:12px 18px;background:var(--primary);color:#fff;border:none;border-radius:10px;font-size:16px;cursor:pointer}
    button:hover{background:var(--primary-hover)}
    .secondary{background:#6c757d}
    .danger{background:var(--danger)}
    /* Modal full-screen mobile-friendly */
    .modal{display:none;position:fixed;inset:0;z-index:9999;background:var(--modal-bg);align-items:center;justify-content:center;padding:env(safe-area-inset);box-sizing:border-box}
    .modal[aria-hidden="false"]{display:flex}
    .modal-content{width:100%;max-width:var(--max-width);background:#fff;border-radius:12px;overflow:hidden;display:flex;flex-direction:column;gap:8px;box-shadow:0 8px 30px rgba(0,0,0,.4)}
    header.modal-header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;background:#fafafa;border-bottom:1px solid #eee}
    header.modal-header h3{margin:0;font-size:16px}
    .camera-stage{position:relative;background:#000;display:flex;align-items:center;justify-content:center;min-height:60vw;max-height:80vh}
    video{width:100%;height:100%;object-fit:cover;display:block;-webkit-transform:translateZ(0)} /* object-fit:cover pour "fill" l'√©cran */
    img.preview{width:100%;height:auto;display:block;object-fit:contain;background:#000}
    .controls{display:flex;gap:8px;padding:10px;flex-wrap:wrap;justify-content:center}
    .status{font-size:13px;color:#555;text-align:center;padding:0 12px 10px}
    .small{font-size:13px;padding:8px 10px}
    .hidden{display:none !important}
    .toggles{display:flex;gap:8px;align-items:center;}
    /* boutons ic√¥nes */
    .icon-btn{display:inline-flex;align-items:center;justify-content:center;padding:8px 10px;border-radius:8px;background:#f2f2f2;color:#222;border:1px solid #e1e1e1;cursor:pointer}
    @media (max-width:520px){
      .modal-content{border-radius:0;height:100vh;max-width:100%}
      header.modal-header{padding:10px}
      .camera-stage{min-height:70vw}
      button{font-size:15px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <h2>Prendre une photo (mobile optimis√©)</h2>
      <button id="openCameraBtn">üì∏ Ouvrir la cam√©ra</button>
    </div>
  </div>

  <!-- Modal -->
  <div id="cameraModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="modalTitle">
    <div class="modal-content" id="modalContent">
      <header class="modal-header">
        <h3 id="modalTitle">Cam√©ra</h3>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="switchBtn" class="icon-btn" title="Changer cam√©ra">üîÅ</button>
          <button id="torchBtn" class="icon-btn hidden" title="Lampe">üî¶</button>
          <button id="closeBtn" class="icon-btn danger" title="Fermer">‚úï</button>
        </div>
      </header>

      <div class="camera-stage" id="cameraStage">
        <video id="video" autoplay playsinline muted></video>
        <img id="photoPreview" class="preview hidden" alt="Aper√ßu de la photo" />
      </div>

      <canvas id="canvas" style="display:none;"></canvas>

      <div class="controls">
        <button id="takePhotoBtn">üì∑ Capturer</button>
        <button id="retakeBtn" class="secondary hidden">‚Ü∫ Reprendre</button>
        <a id="downloadLink" class="secondary hidden" download>‚¨áÔ∏è T√©l√©charger</a>
        <div class="toggles" style="margin-left:6px">
          <label class="small" style="margin:0">Qualit√©
            <select id="qualitySelect">
              <option value="1.0">Max (1.0)</option>
              <option value="0.85">Bonne (0.85)</option>
              <option value="0.7">√âconomie (0.7)</option>
            </select>
          </label>
        </div>
      </div>
      <p id="status" class="status"> </p>
    </div>
  </div>

  <script>
  // --- √©l√©ments DOM ---
  const openCameraBtn = document.getElementById('openCameraBtn');
  const cameraModal = document.getElementById('cameraModal');
  const video = document.getElementById('video');
  const takePhotoBtn = document.getElementById('takePhotoBtn');
  const retakeBtn = document.getElementById('retakeBtn');
  const canvas = document.getElementById('canvas');
  const photoPreview = document.getElementById('photoPreview');
  const downloadLink = document.getElementById('downloadLink');
  const closeBtn = document.getElementById('closeBtn');
  const status = document.getElementById('status');
  const switchBtn = document.getElementById('switchBtn');
  const torchBtn = document.getElementById('torchBtn');
  const qualitySelect = document.getElementById('qualitySelect');
  const cameraStage = document.getElementById('cameraStage');

  // --- √©tat ---
  let stream = null;
  let track = null;
  let imageCapture = null;
  let usingFront = false; // false = rear (environment)
  let capabilities = {};
  let settings = {};
  let lastBlobUrl = null;
  let currentZoom = 1;
  let maxZoom = 1;
  let pinch = {start: null, initialZoom: 1};
  let supportsTorch = false;

  // --- helpers ---
  const log = (...args) => { console.log(...args) };
  function setStatus(text){ status.textContent = text; }

  // Choisit des contraintes adapt√©es au mobile & √† l'√©cran :
  function buildConstraints(useFront) {
    const dpr = window.devicePixelRatio || 1;
    const viewW = Math.round(window.innerWidth * dpr);
    const viewH = Math.round(window.innerHeight * dpr);

    // Limit max capture size to something reasonable to avoid OOM on low-end mobiles
    const maxDim = Math.min(Math.max(viewW, viewH), 3840); // cap ~4k
    const aspect = viewW / viewH;

    // Request camera with ideal resolution near screen size * DPR for best sharpness
    const videoConstraints = {
      facingMode: useFront ? "user" : { ideal: "environment" },
      width: { ideal: Math.round(maxDim * aspect), max: 7680 },
      height: { ideal: Math.round(maxDim / aspect), max: 4320 },
      frameRate: { ideal: 30, max: 60 }, // 30fps is usually enough on mobile
      // advanced: [{ imageStabilization: true }] // browser-dependent
    };

    return { video: videoConstraints, audio: false };
  }

  // Ouverture cam√©ra + setup
  async function openCamera(useFront = false){
    cameraModal.setAttribute('aria-hidden','false');
    setStatus('Initialisation cam√©ra‚Ä¶ autorisez l‚Äôacc√®s si demand√©');

    // build constraints dynamiquement
    const constraints = buildConstraints(useFront);

    try {
      stream = await navigator.mediaDevices.getUserMedia(constraints);
    } catch (err) {
      console.warn('getUserMedia failed with constraints, falling back to basic:', err);
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: true });
      } catch (err2) {
        setStatus('Impossible d‚Äôacc√©der √† la cam√©ra. V√©rifiez les permissions.');
        console.error(err2);
        return;
      }
    }

    track = stream.getVideoTracks()[0];
    capabilities = track.getCapabilities ? track.getCapabilities() : {};
    settings = track.getSettings ? track.getSettings() : {};

    log('Capabilities', capabilities);
    log('Settings', settings);

    // ImageCapture si disponible (meilleure qualit√© pour takePhoto)
    if ('ImageCapture' in window) {
      try {
        imageCapture = new ImageCapture(track);
      } catch (e) {
        imageCapture = null;
      }
    } else {
      imageCapture = null;
    }

    // Torch support (rare on desktops, possible sur mobiles rear)
    supportsTorch = !!(capabilities.torch === true || (capabilities.torch && typeof capabilities.torch === 'boolean'));
    if (supportsTorch) {
      torchBtn.classList.remove('hidden');
    } else {
      torchBtn.classList.add('hidden');
    }

    // Zoom support
    if (capabilities.zoom) {
      maxZoom = capabilities.zoom.max || 1;
      currentZoom = settings.zoom || 1;
      // clamp
      currentZoom = Math.min(Math.max(currentZoom, capabilities.zoom.min || 1), maxZoom);
    } else {
      maxZoom = 1;
      currentZoom = 1;
    }

    // Autofocus availability
    const focusAvailable = capabilities.focusMode && capabilities.focusMode.length;
    if (focusAvailable) {
      try {
        // prefer continuous focus if available
        if (capabilities.focusMode.includes('continuous')) {
          await track.applyConstraints({ advanced: [{ focusMode: 'continuous' }] });
        }
      } catch (e) {
        console.warn('Cannot apply focusMode constraints', e);
      }
    }

    // Apply initial zoom if available (slightly boost to get nearer focal length)
    if (maxZoom > 1) {
      const preferred = Math.min(maxZoom, (capabilities.zoom && capabilities.zoom.max ? capabilities.zoom.max * 0.6 : 1.5));
      try {
        await track.applyConstraints({ advanced: [{ zoom: preferred }] });
        currentZoom = preferred;
      } catch (e) {
        console.warn('unable to set initial zoom', e);
      }
    }

    // Connect stream to video element
    video.srcObject = stream;
    // small hack: unmute to allow autoplay in some Android browsers
    video.muted = true;
    try { await video.play(); } catch(e) { /* ignore */ }

    setStatus('Pr√™t ¬∑ tap pour focus, pince pour zoom, appuyez Capturer');
  }

  // cleanup
  function stopStream() {
    if (!stream) return;
    stream.getTracks().forEach(t => { try{ t.stop(); } catch(e){} });
    stream = null; track = null; imageCapture = null;
    capabilities = {}; settings = {};
    currentZoom = 1; maxZoom = 1;
  }

  // Fermeture modal
  function closeModal(){
    cameraModal.setAttribute('aria-hidden','true');
    setStatus('');
    if (lastBlobUrl) {
      try { URL.revokeObjectURL(lastBlobUrl); } catch(e){}
      lastBlobUrl = null;
    }
    stopStream();
    video.srcObject = null;
    // restore UI
    photoPreview.classList.add('hidden');
    video.classList.remove('hidden');
    takePhotoBtn.classList.remove('hidden');
    retakeBtn.classList.add('hidden');
    downloadLink.classList.add('hidden');
  }

  // Switch cam√©ra (front/back)
  async function switchCamera(){
    usingFront = !usingFront;
    stopStream();
    video.srcObject = null;
    await openCamera(usingFront);
  }

  // Torch toggle (if supported)
  let torchOn = false;
  async function toggleTorch(){
    if (!track) return;
    if (!('torch' in capabilities || capabilities.torch)) {
      setStatus('Torch non support√©e par cet appareil');
      return;
    }
    try {
      torchOn = !torchOn;
      await track.applyConstraints({ advanced: [{ torch: torchOn }] });
      torchBtn.textContent = torchOn ? 'üî¶ ON' : 'üî¶';
    } catch (e) {
      console.warn('Erreur torch', e);
      setStatus('Impossible d‚Äôactiver la lampe');
    }
  }

  // Tap to focus (attempts to set point of interest if supported)
  async function handleTapToFocus(e) {
    if (!capabilities || !track) return;

    // get relative point within video element
    const rect = video.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    const y = (e.clientY - rect.top) / rect.height;

    // Some browsers support pointsOfInterest or focusMode+pointsOfInterest
    if (capabilities.pointsOfInterest || capabilities.focusMode && capabilities.focusMode.includes('single-shot')) {
      try {
        const apply = { advanced: [] };
        if (capabilities.pointsOfInterest) {
          apply.advanced.push({ pointsOfInterest: [{x, y}] });
        }
        if (capabilities.focusMode && capabilities.focusMode.includes('single-shot')) {
          apply.advanced.push({ focusMode: 'single-shot' });
        }
        await track.applyConstraints(apply);
        setStatus('Focus ajust√©');
        return;
      } catch (err) {
        console.warn('tap-to-focus failed', err);
      }
    }

    // Fallback: try toggle continuous focus to nudge AF
    if (capabilities.focusMode && capabilities.focusMode.includes('continuous')) {
      try {
        await track.applyConstraints({ advanced: [{ focusMode: 'continuous' }] });
        setStatus('Focus continous r√©initialis√©');
      } catch (err) { console.warn(err); }
    }
  }

  // Pinch-to-zoom handlers
  function handleTouchStart(e){
    if (!capabilities.zoom) return;
    if (e.touches.length === 2) {
      const [a,b] = e.touches;
      const dist = Math.hypot(a.pageX - b.pageX, a.pageY - b.pageY);
      pinch.start = dist;
      pinch.initialZoom = currentZoom;
    }
  }
  async function handleTouchMove(e){
    if (!capabilities.zoom) return;
    if (e.touches.length === 2 && pinch.start) {
      const [a,b] = e.touches;
      const dist = Math.hypot(a.pageX - b.pageX, a.pageY - b.pageY);
      const ratio = dist / pinch.start;
      let newZoom = pinch.initialZoom * ratio;
      newZoom = Math.max(capabilities.zoom.min || 1, Math.min(newZoom, capabilities.zoom.max || newZoom));
      try {
        await track.applyConstraints({ advanced: [{ zoom: newZoom }] });
        currentZoom = newZoom;
        setStatus(`Zoom: ${newZoom.toFixed(2)}x`);
      } catch (err) {
        // ignore
      }
    }
  }
  function handleTouchEnd(e){
    if (e.touches.length < 2) { pinch.start = null; pinch.initialZoom = 1; }
  }

  // Prise de photo : utilise ImageCapture.takePhoto si dispo, sinon fallback canvas
  async function takePhoto(){
    if (!track && !stream) { setStatus('Cam√©ra non pr√™te'); return; }
    setStatus('Capture en cours‚Ä¶');

    // prefer ImageCapture.takePhoto (garde meilleurs r√©glages)
    try {
      if (imageCapture && typeof imageCapture.takePhoto === 'function') {
        // optionally pass photo settings (width/height) ‚Äî but browsers ignore often
        const quality = parseFloat(qualitySelect.value);
        const blob = await imageCapture.takePhoto(); // photoSettings option is not widely supported
        handleCapturedBlob(blob, quality);
        return;
      }
    } catch (e) {
      console.warn('ImageCapture.takePhoto failed ‚Äî fallback to canvas', e);
      // continue to canvas fallback
    }

    // Canvas fallback: draw current frame, correct orientation and optionally downscale
    try {
      const vW = video.videoWidth;
      const vH = video.videoHeight;
      if (!vW || !vH) {
        setStatus('Frame non disponible ‚Äî r√©essayer');
        return;
      }

      // To limit memory/size, downscale to maxWidth (keep aspect ratio)
      const MAX_OUTPUT = 1920; // cap width or height to 1920
      let outW = vW, outH = vH;
      if (Math.max(outW, outH) > MAX_OUTPUT) {
        const ratio = MAX_OUTPUT / Math.max(outW, outH);
        outW = Math.round(outW * ratio);
        outH = Math.round(outH * ratio);
      }

      // handle device orientation rotation if needed
      const angle = (screen.orientation && screen.orientation.angle) ? screen.orientation.angle : (window.orientation || 0);

      canvas.width = outW;
      canvas.height = outH;
      const ctx = canvas.getContext('2d');

      // If rotation needed, rotate canvas accordingly
      if (angle === 90 || angle === -270) {
        // rotate 90
        const tmp = document.createElement('canvas');
        tmp.width = outH; tmp.height = outW;
        const tctx = tmp.getContext('2d');
        tctx.translate(tmp.width/2, tmp.height/2);
        tctx.rotate(Math.PI/2);
        tctx.drawImage(video, -outW/2, -outH/2, outW, outH);
        // draw tmp to main canvas
        canvas.width = tmp.width; canvas.height = tmp.height;
        ctx.drawImage(tmp, 0, 0);
      } else if (angle === -90 || angle === 270) {
        // rotate -90
        const tmp = document.createElement('canvas');
        tmp.width = outH; tmp.height = outW;
        const tctx = tmp.getContext('2d');
        tctx.translate(tmp.width/2, tmp.height/2);
        tctx.rotate(-Math.PI/2);
        tctx.drawImage(video, -outW/2, -outH/2, outW, outH);
        canvas.width = tmp.width; canvas.height = tmp.height;
        ctx.drawImage(tmp, 0, 0);
      } else if (angle === 180 || angle === -180) {
        ctx.translate(outW, outH);
        ctx.rotate(Math.PI);
        ctx.drawImage(video, 0, 0, outW, outH);
      } else {
        // default no rotation
        ctx.drawImage(video, 0, 0, outW, outH);
      }

      const quality = parseFloat(qualitySelect.value) || 0.9;
      canvas.toBlob(blob => {
        handleCapturedBlob(blob, quality);
      }, 'image/jpeg', quality);

    } catch (err) {
      console.error('Erreur capture canvas', err);
      setStatus('Erreur capture');
    }
  }

  // Gestion du blob captur√© (affichage, download link, nettoyage)
  function handleCapturedBlob(blob, qualityHint){
    if (!blob) {
      setStatus('Capture invalide');
      return;
    }
    if (lastBlobUrl) try { URL.revokeObjectURL(lastBlobUrl); } catch(e){}
    const url = URL.createObjectURL(blob);
    lastBlobUrl = url;
    photoPreview.src = url;
    photoPreview.classList.remove('hidden');
    video.classList.add('hidden');

    downloadLink.href = url;
    const ext = 'jpg';
    const ts = new Date().toISOString().replace(/[:.]/g, '-');
    downloadLink.download = `photo-${ts}.${ext}`;
    downloadLink.classList.remove('hidden');

    takePhotoBtn.classList.add('hidden');
    retakeBtn.classList.remove('hidden');

    setStatus('Photo captur√©e ‚úÖ');
  }

  // Reprendre
  function retake(){
    if (lastBlobUrl) { try { URL.revokeObjectURL(lastBlobUrl); } catch(e){} lastBlobUrl = null; }
    photoPreview.src = '';
    photoPreview.classList.add('hidden');
    downloadLink.classList.add('hidden');
    retakeBtn.classList.add('hidden');
    takePhotoBtn.classList.remove('hidden');
    video.classList.remove('hidden');
    setStatus('Pr√™t ¬∑ Appuyez pour capturer');
  }

  // --- Listeners ---
  openCameraBtn.addEventListener('click', () => openCamera(usingFront));
  closeBtn.addEventListener('click', closeModal);
  cameraModal.addEventListener('click', e => { if (e.target === cameraModal) closeModal(); });
  document.addEventListener('keydown', e => { if (e.key === 'Escape') closeModal(); });

  takePhotoBtn.addEventListener('click', takePhoto);
  retakeBtn.addEventListener('click', retake);
  switchBtn.addEventListener('click', switchCamera);
  torchBtn.addEventListener('click', toggleTorch);

  // TAP-to-focus on video
  video.addEventListener('click', handleTapToFocus);

  // Touch gestures for pinch-to-zoom
  cameraStage.addEventListener('touchstart', handleTouchStart, {passive:true});
  cameraStage.addEventListener('touchmove', handleTouchMove, {passive:false});
  cameraStage.addEventListener('touchend', handleTouchEnd, {passive:true});

  // Clean up when page unloads
  window.addEventListener('pagehide', stopStream);
  window.addEventListener('beforeunload', stopStream);

  // Attempt to keep screen awake (if supported)
  if ('wakeLock' in navigator) {
    let wakeLock = null;
    cameraModal.addEventListener('transitionend', async () => {
      if (cameraModal.getAttribute('aria-hidden') === 'false') {
        try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e) { /* ignore */ }
      } else {
        if (wakeLock) { try { await wakeLock.release(); } catch(e){} wakeLock = null; }
      }
    });
  }

  // Friendly fallback messages for unsupported features
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    openCameraBtn.disabled = true;
    setStatus('Votre navigateur ne supporte pas getUserMedia.');
  }

  // Quick UX: long-press on capture to change quality quickly (example)
  let holdTimer = null;
  takePhotoBtn.addEventListener('touchstart', e => {
    holdTimer = setTimeout(()=> {
      // toggle quality quick
      qualitySelect.value = qualitySelect.value === '1.0' ? '0.85' : '1.0';
      setStatus(`Qualit√©: ${qualitySelect.value}`);
    }, 700);
  }, {passive:true});
  takePhotoBtn.addEventListener('touchend', ()=> { clearTimeout(holdTimer); });

  // Fin du script
  </script>
</body>
</html>
